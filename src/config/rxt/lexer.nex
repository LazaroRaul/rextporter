
/[#].*\n/               { /* eat up comments */ }
/\n[ ]*/                { l = len(token()) - 1; println(indent(l), l) }
/[ \t\n]+/              { /* eat up whitespace */ }
/DATASET|FOR SERVICE|FOR STACK|DEFINE AUTH|AS|SET|TO|GET|POST|FROM|EXTRACT USING|METRIC|NAME|TYPE|GAUGE|COUNTER|HISTOGRAM|SUMMARY|DESCRIPTION|LABELS/ { println("KEY", token()) }
/"[^"]*"/               { println("STR", token()) }
/'[^']*'/               { println("STR", token()) }
/[a-z_][a-z0-9_]*/    { println("VAR", token()) }
//
package main
import "os"
func main() {
  lex := NewLexer(os.Stdin)
  indent_level := 0
  l := 0
  indent_stack := make([]int, 5)
  token := func() string { return lex.Text() }
  indent := func(level int) string {
    if level > indent_level {
      // Open block
      indent_stack = append(indent_stack, indent_level)
      indent_level = level
      return "IND"
    } else {
      if level == indent_level {
        // Same block
        return "IND"
      } else {
        // Close block
        idx := len(indent_stack)
        for level < indent_level {
          idx = idx - 1
          indent_level = indent_stack[idx]
        }
        if level == indent_level {
          indent_stack = indent_stack[:idx]
          return "DED"
        }
        return "ERR"
      }
    }
  }
  NN_FUN(lex)
}

